"use client"

import type React from "react"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group"
import { Label } from "@/components/ui/label"
import { Separator } from "@/components/ui/separator"
import { toast } from "sonner"
import { Download, FileText, File, FileImage, Globe, Loader2, Copy, Share2 } from "lucide-react"
import { cn } from "@/lib/utils"

interface ExportFormat {
  id: string
  name: string
  description: string
  icon: React.ReactNode
  extension: string
  mimeType: string
  premium?: boolean
}

const exportFormats: ExportFormat[] = [
  {
    id: "markdown",
    name: "Markdown",
    description: "Plain text with formatting",
    icon: <FileText className="h-4 w-4" />,
    extension: ".md",
    mimeType: "text/markdown",
  },
  {
    id: "txt",
    name: "Plain Text",
    description: "Simple text without formatting",
    icon: <File className="h-4 w-4" />,
    extension: ".txt",
    mimeType: "text/plain",
  },
  {
    id: "html",
    name: "HTML",
    description: "Web page format",
    icon: <Globe className="h-4 w-4" />,
    extension: ".html",
    mimeType: "text/html",
  },
  {
    id: "pdf",
    name: "PDF",
    description: "Portable document format",
    icon: <FileImage className="h-4 w-4" />,
    extension: ".pdf",
    mimeType: "application/pdf",
    premium: true,
  },
  {
    id: "docx",
    name: "Word Document",
    description: "Microsoft Word format",
    icon: <FileText className="h-4 w-4" />,
    extension: ".docx",
    mimeType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    premium: true,
  },
]

interface ExportOptionsProps {
  content: string
  filename?: string
  documentName?: string
}

export default function ExportOptions({ content, filename = "flashread-summary", documentName }: ExportOptionsProps) {
  const [selectedFormat, setSelectedFormat] = useState("markdown")
  const [isExporting, setIsExporting] = useState(false)

  const selectedFormatData = exportFormats.find((f) => f.id === selectedFormat)

  const convertToPlainText = (markdownContent: string): string => {
    return markdownContent
      .replace(/#{1,6}\s+/g, "") // Remove headers
      .replace(/\*\*(.*?)\*\*/g, "$1") // Remove bold
      .replace(/\*(.*?)\*/g, "$1") // Remove italic
      .replace(/- /g, "â€¢ ") // Convert bullets
      .replace(/\n{3,}/g, "\n\n") // Normalize line breaks
      .trim()
  }

  const convertToHTML = (markdownContent: string): string => {
    const html = markdownContent
      .replace(/#{6}\s+(.*)/g, "<h6>$1</h6>")
      .replace(/#{5}\s+(.*)/g, "<h5>$1</h5>")
      .replace(/#{4}\s+(.*)/g, "<h4>$1</h4>")
      .replace(/#{3}\s+(.*)/g, "<h3>$1</h3>")
      .replace(/#{2}\s+(.*)/g, "<h2>$1</h2>")
      .replace(/#{1}\s+(.*)/g, "<h1>$1</h1>")
      .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
      .replace(/\*(.*?)\*/g, "<em>$1</em>")
      .replace(/^- (.*)$/gm, "<li>$1</li>")
      .replace(/(<li>[\s\S]*?<\/li>)/, "<ul>$1</ul>")
      .replace(/\n\n/g, "</p><p>")
      .replace(/^(?!<[h|u|l])/gm, "<p>")
      .replace(/(?<!>)$/gm, "</p>")

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${documentName || "FlashRead Summary"}</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 2rem; }
        h1, h2, h3 { color: #ea580c; }
        ul { padding-left: 1.5rem; }
        li { margin-bottom: 0.5rem; }
    </style>
</head>
<body>
    ${html}
    <hr>
    <p><small>Generated by FlashRead</small></p>
</body>
</html>`
  }

  const exportContent = async () => {
    if (!selectedFormatData) return

    setIsExporting(true)

    try {
      let exportData: string
      const mimeType = selectedFormatData.mimeType

      switch (selectedFormat) {
        case "txt":
          exportData = convertToPlainText(content)
          break
        case "html":
          exportData = convertToHTML(content)
          break
        case "pdf":
        case "docx":
          // For premium formats, call API
          const response = await fetch("/api/export", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              content,
              format: selectedFormat,
              filename,
              documentName,
            }),
          })

          if (!response.ok) {
            throw new Error("Export failed")
          }

          const blob = await response.blob()
          const url = URL.createObjectURL(blob)
          const a = document.createElement("a")
          a.href = url
          a.download = `${filename}${selectedFormatData.extension}`
          a.click()
          URL.revokeObjectURL(url)

          toast.success(`ðŸ“„ Exported as ${selectedFormatData.name}!`)
          return
        default:
          exportData = content
      }

      // Create and download file
      const blob = new Blob([exportData], { type: mimeType })
      const url = URL.createObjectURL(blob)
      const a = document.createElement("a")
      a.href = url
      a.download = `${filename}${selectedFormatData.extension}`
      a.click()
      URL.revokeObjectURL(url)

      toast.success(`ðŸ“„ Exported as ${selectedFormatData.name}!`)
    } catch (error) {
      toast.error("Failed to export file")
    } finally {
      setIsExporting(false)
    }
  }

  const copyToClipboard = async () => {
    await navigator.clipboard.writeText(content)
    toast.success("ðŸ“‹ Copied to clipboard!")
  }

  const shareContent = async () => {
    if (navigator.share) {
      try {
        await navigator.share({
          title: documentName || "FlashRead Summary",
          text: content,
        })
      } catch (error) {
        // Fallback to clipboard
        copyToClipboard()
      }
    } else {
      copyToClipboard()
    }
  }

  return (
    <div className="flex flex-col h-full bg-background">
      {/* Export Header */}
      <div className="flex items-center justify-between p-4 border-b bg-white/50 dark:bg-zinc-950/50 backdrop-blur-sm">
        <div className="flex items-center gap-2">
          <Download className="h-5 w-5 text-orange-600 dark:text-orange-500" />
          <h2 className="font-semibold text-lg">Export Options</h2>
        </div>
      </div>

      {/* Export Content */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        <RadioGroup value={selectedFormat} onValueChange={setSelectedFormat}>
          <div className="grid gap-3">
            {exportFormats.map((format) => (
              <Label
                key={format.id}
                htmlFor={format.id}
                className={cn(
                  "flex cursor-pointer items-center gap-3 rounded-lg border p-4 transition-all hover:bg-muted/50 [&:has(:checked)]:bg-muted",
                  selectedFormat === format.id &&
                    "border-orange-300 bg-orange-50 dark:border-orange-700 dark:bg-orange-950/30",
                )}
              >
                <RadioGroupItem id={format.id} value={format.id} />
                <div className="flex items-center gap-2 text-orange-600 dark:text-orange-400">{format.icon}</div>
                <div className="flex-1">
                  <div className="flex items-center gap-2">
                    <span className="font-medium">{format.name}</span>
                    {format.premium && (
                      <Badge
                        variant="secondary"
                        className="text-xs bg-orange-100 text-orange-700 dark:bg-orange-950 dark:text-orange-300"
                      >
                        Premium (coming soon)
                      </Badge>
                    )}
                  </div>
                  <p className="text-sm text-muted-foreground">{format.description}</p>
                </div>
                <Badge variant="outline" className="text-xs">
                  {format.extension}
                </Badge>
              </Label>
            ))}
          </div>
        </RadioGroup>

        {selectedFormatData?.premium && (
          <div className="rounded-lg border border-orange-200 bg-orange-50 p-3 dark:border-orange-800 dark:bg-orange-950/20">
            <p className="text-sm text-orange-700 dark:text-orange-300">
              ðŸ’Ž Premium format - Advanced export options available with FlashRead Pro (Coming soon)
            </p>
          </div>
        )}
      </div>

      {/* Export Actions */}
      <div className="p-4 border-t bg-white/80 dark:bg-zinc-950/80 backdrop-blur-sm">
        <Separator className="mb-4" />

        <div className="flex flex-col sm:flex-row gap-2">
          <Button
            onClick={exportContent}
            disabled={isExporting}
            className="bg-orange-600 hover:bg-orange-700 text-white flex-1"
          >
            {isExporting ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Exporting...
              </>
            ) : (
              <>
                <Download className="mr-2 h-4 w-4" />
                Export as {selectedFormatData?.name}
              </>
            )}
          </Button>

          <Button variant="outline" onClick={copyToClipboard} className="sm:w-auto bg-transparent">
            <Copy className="mr-2 h-4 w-4" />
            Copy
          </Button>

          <Button variant="outline" onClick={shareContent} className="sm:w-auto bg-transparent">
            <Share2 className="mr-2 h-4 w-4" />
            Share
          </Button>
        </div>
      </div>
    </div>
  )
}
